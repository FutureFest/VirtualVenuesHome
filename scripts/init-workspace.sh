#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VVH_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

MANIFEST="${VVH_ROOT}/onboarding/repos.github.txt"
UVCS_MANIFEST="${VVH_ROOT}/onboarding/repos.uvcs.txt"
WORKSPACE_DIR="."
NON_INTERACTIVE=0
SKIP_AWS_CHECKS=0
SKIP_GH_CHECKS=0
SKIP_UVCS_CHECKS=0
FORCE_AGENTS=0

declare -a REPOS=()
declare -a UVCS_WORKSPACE_NAMES=()
declare -a UVCS_WORKSPACE_PATHS=()
declare -a UVCS_REPOSITORY_SPECS=()
declare -a GH_ACCESS_FAILURES=()
declare -a AWS_FAILURES=()
declare -a CLONED_REPOS=()
declare -a SKIPPED_REPOS=()
declare -a FAILED_CLONES=()
declare -a CREATED_UVCS=()
declare -a SKIPPED_UVCS=()
declare -a FAILED_UVCS=()

MANAGED_AGENTS_CONTENT="# VirtualVenues Workspace Agent Entry Point

> Managed delegate file generated by \`VirtualVenuesHome/scripts/init-workspace.sh\`
> and \`VirtualVenuesHome/scripts/init-workspace.ps1\`.
> Update source guidance in \`VirtualVenuesHome/AGENTS.md\` and these scripts,
> then regenerate root \`AGENTS.md\` with \`--force-agents\`.
> Do not edit root \`AGENTS.md\` directly.

This workspace root is a container directory and is **not** a Git repository.
For repository-level operations, run Git commands inside the specific
sub-repository folder.

Primary shared agent guidance for this multi-repo strategy lives in:

- \`VirtualVenuesHome/AGENTS.md\`

Treat each subfolder in this workspace as a standalone repository with its own
README and tooling. Make changes inside the specific subfolder you are working
on.

## Top-Level Folders That Are Not Git Repositories

These workspace folders currently do not contain a \`.git\` directory:

- \`FutureFestWorlds\`
- \`FutureFestXR\`
- \`VirtualVenuesWorldCreator\`
"

usage() {
  cat <<'EOF'
Usage: init-workspace.sh [options]

Options:
  --manifest <path>       Path to repo manifest file
  --uvcs-manifest <path>  Path to UVCS manifest file
  --workspace-dir <path>  Workspace directory to operate in (default: .)
  --non-interactive       Fail fast instead of attempting interactive login
  --skip-aws-checks       Skip AWS profile preflight checks
  --skip-gh-checks        Skip GitHub auth/repo-access preflight checks
  --skip-uvcs-checks      Skip UVCS auth preflight checks
  --force-agents          Overwrite existing AGENTS.md with managed delegate
  -h, --help              Show this help
EOF
}

log() {
  printf '[INFO] %s\n' "$*"
}

warn() {
  printf '[WARN] %s\n' "$*" >&2
}

fatal() {
  printf '[ERROR] %s\n' "$*" >&2
  exit 1
}

require_cmd() {
  local cmd="$1"
  if ! command -v "$cmd" >/dev/null 2>&1; then
    fatal "Required command not found: ${cmd}"
  fi
}

trim_line() {
  local value="$1"
  value="${value%$'\r'}"
  value="$(echo "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
  printf '%s' "$value"
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --manifest)
        [[ $# -ge 2 ]] || fatal "--manifest requires a value"
        MANIFEST="$2"
        shift 2
        ;;
      --workspace-dir)
        [[ $# -ge 2 ]] || fatal "--workspace-dir requires a value"
        WORKSPACE_DIR="$2"
        shift 2
        ;;
      --uvcs-manifest)
        [[ $# -ge 2 ]] || fatal "--uvcs-manifest requires a value"
        UVCS_MANIFEST="$2"
        shift 2
        ;;
      --non-interactive)
        NON_INTERACTIVE=1
        shift
        ;;
      --skip-aws-checks)
        SKIP_AWS_CHECKS=1
        shift
        ;;
      --skip-gh-checks)
        SKIP_GH_CHECKS=1
        shift
        ;;
      --skip-uvcs-checks)
        SKIP_UVCS_CHECKS=1
        shift
        ;;
      --force-agents)
        FORCE_AGENTS=1
        shift
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        fatal "Unknown option: $1"
        ;;
    esac
  done
}

resolve_path() {
  local input="$1"
  if [[ "$input" = /* ]]; then
    printf '%s' "$input"
  else
    printf '%s/%s' "$(pwd)" "$input"
  fi
}

load_manifest() {
  local line cleaned

  [[ -f "$MANIFEST" ]] || fatal "Manifest not found: ${MANIFEST}"

  while IFS= read -r line || [[ -n "$line" ]]; do
    cleaned="${line%%#*}"
    cleaned="$(trim_line "$cleaned")"

    [[ -z "$cleaned" ]] && continue

    if [[ ! "$cleaned" =~ ^[A-Za-z0-9_.-]+/[A-Za-z0-9_.-]+$ ]]; then
      fatal "Invalid manifest entry: ${cleaned}"
    fi

    REPOS+=("$cleaned")
  done < "$MANIFEST"

  if [[ ${#REPOS[@]} -eq 0 ]]; then
    fatal "Manifest is empty: ${MANIFEST}"
  fi
}

load_uvcs_manifest() {
  local line cleaned name repo_path repo_spec
  local IFS='|'

  if [[ ! -f "$UVCS_MANIFEST" ]]; then
    fatal "UVCS manifest not found: ${UVCS_MANIFEST}"
  fi

  while IFS= read -r line || [[ -n "$line" ]]; do
    cleaned="${line%%#*}"
    cleaned="$(trim_line "$cleaned")"
    [[ -z "$cleaned" ]] && continue

    read -r name repo_path repo_spec <<< "$cleaned"

    name="$(trim_line "${name:-}")"
    repo_path="$(trim_line "${repo_path:-}")"
    repo_spec="$(trim_line "${repo_spec:-}")"

    if [[ -z "$name" || -z "$repo_path" || -z "$repo_spec" ]]; then
      fatal "Invalid UVCS manifest entry: ${line}"
    fi

    UVCS_WORKSPACE_NAMES+=("$name")
    UVCS_WORKSPACE_PATHS+=("$repo_path")
    UVCS_REPOSITORY_SPECS+=("$repo_spec")
  done < "$UVCS_MANIFEST"
}

ensure_agents_delegate() {
  local workspace_abs="$1"
  local agents_path="${workspace_abs}/AGENTS.md"
  local tmp_file

  tmp_file="$(mktemp)"
  printf '%s' "$MANAGED_AGENTS_CONTENT" > "$tmp_file"

  if [[ -f "$agents_path" ]]; then
    if cmp -s "$tmp_file" "$agents_path"; then
      log "AGENTS delegate already up to date: ${agents_path}"
    elif [[ "$FORCE_AGENTS" -eq 1 ]]; then
      cp "$tmp_file" "$agents_path"
      log "AGENTS delegate overwritten: ${agents_path}"
    else
      warn "AGENTS.md exists and differs from managed delegate: ${agents_path}"
      warn "Root AGENTS.md is a generated delegate; do not edit it directly."
      warn "Update VirtualVenuesHome/AGENTS.md and init-workspace script templates."
      warn "Use --force-agents to overwrite it."
    fi
  else
    cp "$tmp_file" "$agents_path"
    log "AGENTS delegate created: ${agents_path}"
  fi

  rm -f "$tmp_file"
}

check_uvcs_access() {
  local repo_spec repserver seen_servers

  seen_servers="|"
  for repo_spec in "${UVCS_REPOSITORY_SPECS[@]}"; do
    repserver="${repo_spec#*@}"
    if [[ -z "$repserver" || "$repserver" == "$repo_spec" ]]; then
      fatal "Invalid UVCS repository spec in manifest: ${repo_spec}"
    fi

    if [[ "$seen_servers" == *"|${repserver}|"* ]]; then
      continue
    fi
    seen_servers="${seen_servers}${repserver}|"

    if ! cm checkconnection "$repserver" >/dev/null 2>&1; then
      fatal "UVCS check failed for ${repserver}. Authenticate and retry."
    fi
  done

  if ! cm whoami >/dev/null 2>&1; then
    fatal "UVCS identity check failed. Authenticate with Unity Version Control, then retry."
  fi
}

check_gh_access() {
  local repo="$1"
  if ! gh repo view "$repo" --json name >/dev/null 2>&1; then
    GH_ACCESS_FAILURES+=("$repo")
  fi
}

check_aws_profile() {
  local profile="$1"

  if aws sts get-caller-identity --profile "$profile" >/dev/null 2>&1; then
    log "AWS profile check passed: ${profile}"
    return 0
  fi

  if [[ "$NON_INTERACTIVE" -eq 1 || ! -t 0 ]]; then
    AWS_FAILURES+=("$profile")
    return 1
  fi

  warn "AWS profile ${profile} is not authenticated. Attempting aws sso login."
  if aws sso login --profile "$profile"; then
    if aws sts get-caller-identity --profile "$profile" >/dev/null 2>&1; then
      log "AWS profile check passed after login: ${profile}"
      return 0
    fi
  fi

  AWS_FAILURES+=("$profile")
  return 1
}

preflight_checks() {
  require_cmd git
  require_cmd gh

  if [[ "$SKIP_AWS_CHECKS" -eq 0 ]]; then
    require_cmd aws
  fi

  if [[ "$SKIP_GH_CHECKS" -eq 0 ]]; then
    if ! gh auth status >/dev/null 2>&1; then
      fatal "GitHub CLI is not authenticated. Run: gh auth login"
    fi

    for repo in "${REPOS[@]}"; do
      check_gh_access "$repo"
    done

    if [[ ${#GH_ACCESS_FAILURES[@]} -gt 0 ]]; then
      printf '[ERROR] GitHub access check failed for:\n' >&2
      printf '  - %s\n' "${GH_ACCESS_FAILURES[@]}" >&2
      fatal "Fix GitHub org/repo access or use --skip-gh-checks."
    fi
  else
    log "Skipping GitHub preflight checks."
  fi

  if [[ "$SKIP_AWS_CHECKS" -eq 0 ]]; then
    check_aws_profile "futurefest-mgmt" || true
    check_aws_profile "futurefest-mgmt-ro" || true

    if [[ ${#AWS_FAILURES[@]} -gt 0 ]]; then
      printf '[ERROR] AWS profile check failed for:\n' >&2
      printf '  - %s\n' "${AWS_FAILURES[@]}" >&2
      if [[ "$NON_INTERACTIVE" -eq 1 || ! -t 0 ]]; then
        fatal "Authenticate first: aws sso login --profile <profile>, then rerun."
      fi
      fatal "Unable to authenticate required AWS profiles."
    fi
  else
    log "Skipping AWS preflight checks."
  fi

  if [[ ${#UVCS_WORKSPACE_NAMES[@]} -gt 0 ]]; then
    require_cmd cm
    if [[ "$SKIP_UVCS_CHECKS" -eq 0 ]]; then
      check_uvcs_access
      log "UVCS preflight checks passed."
    else
      log "Skipping UVCS preflight checks."
    fi
  else
    log "No UVCS manifest entries found; skipping UVCS bootstrap."
  fi
}

clone_github_repos() {
  local workspace_abs="$1"
  local repo target_name target_path

  for repo in "${REPOS[@]}"; do
    target_name="${repo##*/}"
    target_path="${workspace_abs}/${target_name}"

    if [[ -e "$target_path" ]]; then
      SKIPPED_REPOS+=("$repo")
      log "Skipping existing repo directory: ${target_name}"
      continue
    fi

    if (cd "$workspace_abs" && gh repo clone "$repo" "$target_name"); then
      CLONED_REPOS+=("$repo")
      log "Cloned ${repo} -> ${target_name}"
    else
      FAILED_CLONES+=("$repo")
      warn "Failed to clone ${repo}"
    fi
  done
}

resolve_target_path() {
  local workspace_abs="$1"
  local repo_path="$2"

  if [[ "$repo_path" = /* ]]; then
    printf '%s' "$repo_path"
  else
    printf '%s/%s' "$workspace_abs" "$repo_path"
  fi
}

init_uvcs_workspaces() {
  local workspace_abs="$1"
  local i workspace_name repo_path repo_spec target_path parent_path

  for ((i = 0; i < ${#UVCS_WORKSPACE_NAMES[@]}; i++)); do
    workspace_name="${UVCS_WORKSPACE_NAMES[$i]}"
    repo_path="${UVCS_WORKSPACE_PATHS[$i]}"
    repo_spec="${UVCS_REPOSITORY_SPECS[$i]}"
    target_path="$(resolve_target_path "$workspace_abs" "$repo_path")"
    parent_path="$(dirname "$target_path")"

    if [[ -e "$target_path" ]]; then
      SKIPPED_UVCS+=("$workspace_name")
      log "Skipping existing UVCS target: ${target_path}"
      continue
    fi

    mkdir -p "$parent_path"

    if cm workspace create "$workspace_name" "$target_path" "$repo_spec" >/dev/null 2>&1; then
      if (cd "$target_path" && cm update >/dev/null 2>&1); then
        CREATED_UVCS+=("$workspace_name")
        log "Created UVCS workspace ${workspace_name} at ${target_path}"
      else
        FAILED_UVCS+=("$workspace_name")
        warn "Workspace created but update failed for ${workspace_name}"
      fi
    else
      FAILED_UVCS+=("$workspace_name")
      warn "Failed to create UVCS workspace ${workspace_name}"
    fi
  done
}

main() {
  local workspace_abs

  parse_args "$@"

  if [[ ! -d "$WORKSPACE_DIR" ]]; then
    mkdir -p "$WORKSPACE_DIR"
  fi

  workspace_abs="$(cd "$WORKSPACE_DIR" && pwd)"
  MANIFEST="$(resolve_path "$MANIFEST")"
  UVCS_MANIFEST="$(resolve_path "$UVCS_MANIFEST")"

  load_manifest
  load_uvcs_manifest
  preflight_checks
  ensure_agents_delegate "$workspace_abs"
  clone_github_repos "$workspace_abs"
  init_uvcs_workspaces "$workspace_abs"

  log "Summary:"
  log "  GitHub cloned:  ${#CLONED_REPOS[@]}"
  log "  GitHub skipped: ${#SKIPPED_REPOS[@]}"
  log "  GitHub failed:  ${#FAILED_CLONES[@]}"
  log "  UVCS created:   ${#CREATED_UVCS[@]}"
  log "  UVCS skipped:   ${#SKIPPED_UVCS[@]}"
  log "  UVCS failed:    ${#FAILED_UVCS[@]}"

  if [[ ${#FAILED_CLONES[@]} -gt 0 ]]; then
    printf '[ERROR] GitHub clone failures:\n' >&2
    printf '  - %s\n' "${FAILED_CLONES[@]}" >&2
  fi

  if [[ ${#FAILED_UVCS[@]} -gt 0 ]]; then
    printf '[ERROR] UVCS workspace failures:\n' >&2
    printf '  - %s\n' "${FAILED_UVCS[@]}" >&2
  fi

  if [[ ${#FAILED_CLONES[@]} -gt 0 || ${#FAILED_UVCS[@]} -gt 0 ]]; then
    exit 1
  fi
}

main "$@"
